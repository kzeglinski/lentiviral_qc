[
  {
    "objectID": "bioinf.html",
    "href": "bioinf.html",
    "title": "Bioinformatics tutorial",
    "section": "",
    "text": "This section will walk you through the process of analysing long-read sequencing data from lentiviral vectors.\nBefore you begin the analysis, make sure to do some QC with your QC tool of choice (I like NanoQC). If necessary, you can also include ‘failed’ (lower quality) reads in the analysis, as accuracy is not so important when we are simply looking at the length of the lentiviral RNA."
  },
  {
    "objectID": "bioinf.html#aligning-to-the-vector",
    "href": "bioinf.html#aligning-to-the-vector",
    "title": "Bioinformatics tutorial",
    "section": "Aligning to the vector",
    "text": "Aligning to the vector\nWe will align reads to the vector reference sequence using minimap2. First, we will align into the PAF format (this is a simple tab-separated format that makes it easy for us to find the 3’ ends of reads):\n\nminimap2 -x splice -L --MD reference.fasta all_reads.fastq &gt; vector_alignment.paf\n\nWhere:\n\n-x splice uses the splice preset for alignment (will help to identify splicing events in reads)\n-L --MD modify the output format (not really important for this case)\n\nAdditionally, we will align into the SAM format, which is useful for finding the sequencing coverage (we could also use this file to find the 3’ read ends, but it’s just easier to use the PAF).\n\nminimap2 -ax splice -L --MD reference.fasta all_reads.fastq &gt; vector_alignment.sam\n\n# convert to BAM, sort and index\nsamtools view -b vector_alignment.sam &gt; vector_alignment.bam\nsamtools sort vector_alignment.bam &gt; vector_alignment_sorted.bam\nrm vector_alignment.bam vector alignment.sam # don't need these anymore\nsamtools index vector_alignment_sorted.bam\n\n\n\n\n\n\n\nNote\n\n\n\nNote: in order to determine the percentage of reads aligned to the vector vs those aligned to the human genome, it’s best to align to a hybrid reference (which can be generated by using cat to combine the vector FASTA to an appropriate genome, like CHM13), remembering to disable secondary alignments with --secondary=no.\n\n\n\nSequencing coverage\nTo find the sequencing coverage, we will use samtools depth as follows:\n\nsamtools depth -a -d 0 vector_alignment_sorted.bam &gt; vector_coverage.tsv\n\nWhere:\n\n-a outputs all positions, even those with zero coverage\n-d 0 removes the upper limit on coverage (otherwise, the coverage plot will be capped at a certain y value, leading to a flat, ‘shaven’ appearance)"
  },
  {
    "objectID": "bioinf.html#splicing",
    "href": "bioinf.html#splicing",
    "title": "Bioinformatics tutorial",
    "section": "Splicing",
    "text": "Splicing\nSplicing can be plotted from the BAM file using ggsashimi, as follows:\n\npython ./ggsashimi/ggsashimi.py -b vector_alignment_sorted.bam -c vector:329-6582 -M 3\n\nWhere:\n\n-c should be in the format ref_name:start-end, giving the name of the reference sequence and start/end positions for the plot\n-M 3 only plots splicing events with at least 3 supporting reads"
  },
  {
    "objectID": "bioinf.html#plotting-in-r",
    "href": "bioinf.html#plotting-in-r",
    "title": "Bioinformatics tutorial",
    "section": "Plotting in R",
    "text": "Plotting in R\nWe will combine these outputs to create plots in R that give an overal picture of the lentiviral RNA sequencing quality. First, we need to load the required packages:\n\nlibrary(GenomicRanges)\nlibrary(readr)\nlibrary(rtracklayer) # read gff\nlibrary(ggplot2) # make other plots\nlibrary(gggenes) # make ref plot\nlibrary(cowplot) # combine plots\nlibrary(ggrepel)\nlibrary(grid)\nlibrary(dplyr)\n\nEach of the panels in our plot will be created seperately, and then we will use the cowplot package to combine them into one figure. First, the reference panel using the gggenes package:\n\n# first clean up the reference a little and format it for gggenes\nreference &lt;- import.gff(\"reference_annotation.gff\")\n\n# this reference is already pretty clean, but here's some code that can be useful for cleaning up:\n# restrict() which allows you to remove annotations outside of the transcribed region\n# disjointBins() which creates a vector that groups annotations together such that no group\n# contains overlapping annotations. This is a good way to force things onto separate tracks so\n# that the text isn't overlapping and hard to read\n\nreference &lt;- as.data.frame(reference)\nreference &lt;- data.frame(\n    seqnames = rep(\"LV6\", nrow(reference)),\n    start = reference$start,\n    end = reference$end,\n    strand = reference$strand,\n    id = reference$label,\n    group = reference$type, # colour annotations based on their type\n    plotting_track = rep(\"1\", nrow(reference))) # we want all annotations on a single track\nreference$forward &lt;- ifelse(reference$strand == \"+\", TRUE, FALSE)\n\n# make the plot\nreference_plot &lt;- ggplot(\n    reference,\n    aes(xmin = start, xmax = end, y = plotting_track, fill = group,\n        label = id, col = group, forward = forward)) +\n    geom_gene_arrow( # modify the sizes to get the arrow shape you like\n        arrowhead_height = grid::unit(6, \"mm\"), arrow_body_height = grid::unit(5, \"mm\"),\n        arrowhead_width = grid::unit(6, \"mm\")) +\n    # important: set the x axis (position) limits based on the transcribed region for\n    # each plot panel. this ensures the panels will line up properly\n    scale_x_continuous(limits = c(330, 6273), n.breaks = 10, expand = expansion(0, 0)) +\n    # if you want multiple tracks, use facet_wrap(~ track_column)\n    theme_genes() +\n    theme(legend.position = \"bottom\", axis.text.y=element_blank()) +\n    xlab(\"Position\") +\n    ylab(\"Reference\") +\n    # we will use ggrepel to label the annotations in a way that will minimise text overlap\n    # alternatively you can use gggenes geom_gene_label() function to put the labels within\n    # the shapes, but this doesn't work well for small annotations\n    geom_text_repel( # put every second label above\n        data = reference %&gt;%\n        mutate(start = (start + end)/2) %&gt;%\n        dplyr::slice(which(row_number() %% 2 != 0)),\n        aes(x = start, y = plotting_track, label = id),\n        inherit.aes = F, force = 3, nudge_y = 0.2, nudge_x = -0.1) +\n    geom_text_repel( # and every other label below\n        data = reference %&gt;%\n        mutate(start = (start + end)/2) %&gt;%\n        dplyr::slice(which(row_number() %% 2 == 0)),\n        aes(x = start, y = plotting_track, label = id),\n        inherit.aes = F, force = 3, nudge_y = -0.2, nudge_x = 0.1)\n\nreference_plot\n\n\n\n\n\n\n\n\nNow that we have the reference plot, we can add in the coverage and 3’ end information:\n\n# read in the coverage data\ncoverage_data &lt;- read_tsv(\"coverage.tsv\", col_names = c(\"chr\", \"pos\",\"coverage\"))\ncoverage_data &lt;- coverage_data[330:6273,] # as mentioned above, specify the start & end points\n\n# coverage-only plot\ncoverage_plot &lt;- ggplot(coverage_data, aes(pos, coverage)) +\n    geom_area(fill = \"#1b9e77\", alpha = 0.5) +\n    scale_x_continuous(limits = c(330, 6273), n.breaks = 10,\n                       expand = expansion(0, 0), name = NULL) +\n    theme_minimal()\n\ncoverage_plot\n\n\n\n\n\n\n\n# read in the 3' end data\nthree_prime_data &lt;- read_tsv(\n    \"three_prime_ends.paf\",\n    col_names = c(\"query_name\", \"query_len\", \"query_start\", \"query_end\", \"rel_strand\",\n                  \"target_name\", \"target_len\", \"target_start\", \"target_end\", \"num_matches\",\n                  \"align_block_len\", \"qual\"))\n# you can use this dataframe to calculate the % of reads that terminate in certain locations\n\n# plot with sequencing coverage and 3' read ends\nthree_prime_plot &lt;- ggplot(three_prime_data, aes(target_end)) +\n    # add coverage data\n    geom_area(data = coverage_data, aes(pos, coverage), fill = \"#1b9e77\", alpha = 0.5) +\n    # add the 3' end peaks after coverage so they're in the front\n    geom_area(\n        aes(y = ..count..), stat = \"bin\", binwidth = 30, # choose appropriate bin size\n        col = \"#d95f02\", fill = \"#d95f02\", alpha = 0.6) +\n    scale_x_continuous(limits = c(330, 6273),\n                       n.breaks = 10, expand = expansion(0, 0), name = NULL) +\n    theme_minimal()\n\n# combine these plots with the reference\n# first align the plots\naligned_plots &lt;- align_plots(\n    three_prime_plot, coverage_plot, reference_plot,\n    align = 'v', axis = 'l')\n\n# then you can actually plot them\nplot_grid(\n    aligned_plots[[1]],\n    aligned_plots[[2]], # these are the three plots we aligned\n    aligned_plots[[3]],\n    ncol = 1, # we want them all stacked on top of one another\n    rel_heights = c(1, 1, 2) # set size for each plot: if you have a lot of annotations put the reference as 2 vs the 1 for the coverage/3' end plots e.g. c(1, 1, 2)\n)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Long-read sequencing for lentiviral vector QC",
    "section": "",
    "text": "Welcome to the website!\nAt the top of the page, you can find a link to the in-depth bioinformatics tutorial. More content might be added later as we continue to improve this method!\nSome other things you might want to look at are:\n\nthe pre-print"
  }
]